# Downloading the photos to the mobile app

Your back end is now complete, with APIs to upload and download photos. The mobile app can take a photo, check it for happy Xamarin developers and upload the photo to the back end.

The next step is to extend the Azure service to be able to download photos to the mobile device. Head back to your Xamarin mobile app, where you will need to add code to the Azure service to download all the photo metadata as well as downloading the individual photos.

## Creating a data object for photo metadata

1. The `GetAllPhotos` Azure Function returns a collection of JSON objects with a load of fields, some that you want, some that you don't. You will need to create a simple C# data object in your mobile app that these JSON objects can be deserialized into to get the relevant fields. In the `Services` folder, add a new class called `PhotoMetadata` with the following properties:

    | Property    | Type       | Description                                                        |
    | ----------- | ---------- | ------------------------------------------------------------------ |
    | `Name`      | `string`   | The name of the Blob that contains the actual photo                |
    | `Caption`   | `string`   | The caption for the photo generated by the Computer Vision service |
    | `Tags`      | `string[]` | The tags for the photo generated by the Computer Vision service    |
    | `Timestamp` | `long`     | A timestamp for when the document was created                      |

    ```cs
    public class PhotoMetadata
    {
        public string Name { get; set; }
        public string Caption { get; set; }
        public string[] Tags { get; set; }
        public long Timestamp { get; set; }
    }
    ```

2. To deserialize the JSON you will be using [Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/) under the hood as part of the MobileClient API, and this maps fields in the JSON to properties by name. Most of the properties will map directly to the fields that come back from Cosmos DB, for example the "Name" field in the document will map to the `Name` property. One field won't map, and this is `Timestamp`. Every Cosmos DB document gets a timestamp field created automatically called `_ts`, and this contains the time the document was inserted or last updated using a UNIX timestamp (the number of elapsed seconds since January 1, 1970). You can tell Newtonsoft.JSON to map the `_ts` field to the `Timestamp` property using the `JsonProperty` attribute on the property. You will need to add a using directive for the `Newtonsoft.Json` namespace.

    ```cs
    [JsonProperty("_ts")]
    public long Timestamp { get; set; }
    ```

## Downloading individual photos

For each photo metadata item that will be downloaded, your app will need to download the actual photos. This is a slow network call, so ideally your app should cache these photos locally to avoid having to re-download the files each time. The method to do this should check if the file exists using the Blob name as the file name, and if it doesn't exist, download the image.

### Configuring the file location

Each platform has different rules around file storage, and different locations to save files to. Handling the different cases for iOS, Android and UWP is complicated and involves some platform specific code (similar to how you implemented the authentication). To make life easier for Xamarin developers, Microsoft has a NuGet package called [Xamarin.Essentials](https://www.nuget.org/packages/Xamarin.Essentials) that provides cross-platform implementations of common platform-specific functionality including a helper to provide a storage location that works on all platforms. This is currently available as a pre-release NuGet package.

The [Xamarin Essentials File System](https://docs.microsoft.com/xamarin/essentials/file-system-helpers/?WT.mc_id=mobileappsoftomorrow-workshop-jabenn) helpers class has two directories available. `CacheDirectory` is a local cache for transient data, such as photos. Data saved here is not backed up with your application. `AppDataDirectory` is for application data that should be backed up such as downloaded assets.

1. Add the "Xamarin.Essentials" NuGet package to all the projects in your app. You will need to tick the _pre-release_ option (_include prerelease_ on Windows) before searching for this package.

2. On Android, there is some additional setup that needs to be done to enable the new permissions APIs added since Android Marshmallow. In the `MainActivity` class, add the following line to of the `OnCreate` method, before the call to `LoadApplication`.

    ```cs
    protected override void OnCreate(Bundle bundle)
    {
        ...
        Xamarin.Essentials.Platform.Init(this, bundle);
        LoadApplication(new App());
    }
    ```

3. The file name that the photo will be saved under will need to include the path to the local cache folder. Add a new read-only property to the `PhotoMetadata` class to return a file name, using the Blob name as part of this. You will need to add a using directive for the `System.IO` and `Xamarin.Essentials` namespaces.

    ```cs
    public class PhotoMetadata
    {
        public string FileName => Path.Combine(FileSystem.CacheDirectory, $"{Name}.jpg");
        ...
    }
    ```

> For a production quality app you should also think about working off-line such as caching the metadata, and reducing network load by providing ways to only download new metadata each time. You should also consider connectivity and not try to download if the device is offline, something you can check using the [Xamarin Essentials Connectivity](https://docs.microsoft.com/xamarin/essentials/connectivity/?WT.mc_id=mobileappsoftomorrow-workshop-jabenn) class. This is outside the scope of this workshop.

### Downloading and saving photos

1. In the `IAzureService` interface, add a new method declaration to download a photo.

    ```cs
    Task DownloadPhoto(PhotoMetadata photoMetadata);
    ```

2. In the `AzureServiceBase` class, implement this as an `async` method.

    ```cs
    public async Task DownloadPhoto(PhotoMetadata photoMetadata)
    {
    }
    ```

3. In the `DownloadPhoto` method, check to see if the file exists, if it does return from the method straight away. You might need to add the `System.IO` namespace to the `using` section.

    ```cs
    if (File.Exists(photoMetadata.FileName))
        return;
    ```

4. If the file doesn't exist, add code to make a GET request to the `photo/{name}` Azure Function using the `MobileClient`. The name of the photo resource will be the `Name` property from the photo metadata. You will also need to add the `System.Net.Http` namespace to the `using` section.

    ```cs
    var response = await Client.InvokeApiAsync($"photo/{photoMetadata.Name}",
                                               HttpMethod.Get,
                                               new Dictionary<string, string>());
    ```

5. The call to `InvokeApiAsync` returns a `JToken`, an object from `Newtonsoft.Json` that provides functionality to read data from a JSON payload. The field on the JSON that we want is the "Photo" field, so extract the value for this field.

    ```cs
    var photo = response["Photo"].Value<string>();
    ```

6. This value is a Base64 encoded photo, so convert it to a byte array.

    ```cs
    var bytes = Convert.FromBase64String(photo);
    ```

7. Save these bytes to a file using the FileName from the photo metadata.

    ```cs
    using (var fs = new FileStream(photoMetadata.FileName, FileMode.CreateNew))
        await fs.WriteAsync(bytes, 0, bytes.Length);
    ```

The full code for this method is below.

```cs
public async Task DownloadPhoto(PhotoMetadata photoMetadata)
{
    if (File.Exists(photoMetadata.FileName))
        return;

    var result = await Client.InvokeApiAsync($"photo/{photoMetadata.Name}",
                                                HttpMethod.Get,
                                                new Dictionary<string, string>());

    var photo = result["Photo"].Value<string>();
    var bytes = Convert.FromBase64String(photo);

    using (var fs = new FileStream(photoMetadata.FileName, FileMode.CreateNew))
        await fs.WriteAsync(bytes, 0, bytes.Length);
}
```

## Downloading the photo metadata

1. Head to the `IAzureService` interface and add a new asynchronous method declaration to get all photo metadata as an enumerable collection of `PhotoMetadata`.

    ```cs
    Task<IEnumerable<PhotoMetadata>> GetAllPhotoMetadata();
    ```

2. Head to the `AzureServiceBase` and implement this method signature as an `async` method.

    ```cs
    public async Task<IEnumerable<PhotoMetadata>> GetAllPhotoMetadata()
    {
    }
    ```

3. Call the `photos` API with an HTTP Get method to get the photo metadata from the `GetAllPhotos` Azure Function. The `InvokeApi` method on the mobile client has an overload that takes a generic type argument and will automatically deserialize the JSON returned by the GET method into the type specified.

    ```cs
    var allMetadata = await Client.InvokeApiAsync<List<PhotoMetadata>>(PhotoResource,
                                                                       HttpMethod.Get,
                                                                       new Dictionary<string, string>());
    ```

4. For each item in the photo metadata, your app should download the actual photo if it hasn't already been downloaded using the new `DownloadPhoto` method.

    ```cs
    foreach (var metadata in allMetadata)
        await DownloadPhoto(metadata);
    ```

5. Finally return the metadata.

    ```cs
    return allMetadata;
    ```

The full code for this method is shown below.

```cs
public async Task<IEnumerable<PhotoMetadata>> GetAllPhotoMetadata()
{
    var allMetadata = await Client.InvokeApiAsync<List<PhotoMetadata>>(PhotoResource,
                                                                    HttpMethod.Get,
                                                                    new Dictionary<string, string>());

    foreach (var metadata in allMetadata)
        await DownloadPhoto(metadata);

    return allMetadata;
}
```

## Next step

Now that you have photos downloaded, the next step is to [show these photos on the UI](./12-ShowPhotosOnMobileApp.md).